<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>GraphLib: GraphLib::Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GraphLib
   &#160;<span id="projectnumber">1.42</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGraphLib.html">GraphLib</a></li><li class="navelem"><a class="el" href="classGraphLib_1_1Graph.html">Graph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classGraphLib_1_1Graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GraphLib::Graph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Graph_8hh_source.html">Graph.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf3c67e9e04fd94b80556ccbfa492a2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraphLib_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#acf3c67e9e04fd94b80556ccbfa492a2d">operator=</a> (const <a class="el" href="classGraphLib_1_1Graph.html">Graph</a> &amp;)=delete</td></tr>
<tr class="separator:acf3c67e9e04fd94b80556ccbfa492a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f9277bc44213e8ec100eccfdc4a33e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ab8f9277bc44213e8ec100eccfdc4a33e">Graph</a> (bool graphType=<a class="el" href="classGraphLib_1_1Graph.html#a3111bb6cc59aedbc4290ed1b37668336">directed</a>)</td></tr>
<tr class="separator:ab8f9277bc44213e8ec100eccfdc4a33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3fbf053855797d1da4df1421ee216f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a7e3fbf053855797d1da4df1421ee216f">Graph</a> (std::string regex, int edgeMode, bool graphType=<a class="el" href="classGraphLib_1_1Graph.html#a3111bb6cc59aedbc4290ed1b37668336">directed</a>)</td></tr>
<tr class="separator:a7e3fbf053855797d1da4df1421ee216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb8d04de0175ec4005ee57564a8802c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a3fb8d04de0175ec4005ee57564a8802c">Graph</a> (const <a class="el" href="classGraphLib_1_1Graph.html">Graph</a> &amp;)</td></tr>
<tr class="separator:a3fb8d04de0175ec4005ee57564a8802c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bde368ad387204b3e1407fe6c93f51"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a40bde368ad387204b3e1407fe6c93f51">~Graph</a> ()=default</td></tr>
<tr class="separator:a40bde368ad387204b3e1407fe6c93f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f6b627345753c59f03600b2dbc8113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraphLib_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a13f6b627345753c59f03600b2dbc8113">transpose</a> ()</td></tr>
<tr class="separator:a13f6b627345753c59f03600b2dbc8113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60547325c70266ede08ed887ff60ea19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a60547325c70266ede08ed887ff60ea19">DFS</a> (std::string sourceNode)</td></tr>
<tr class="separator:a60547325c70266ede08ed887ff60ea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dae6a27fc7ccfc7043680a650e34c06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a5dae6a27fc7ccfc7043680a650e34c06">BFS</a> (std::string sourceNode)</td></tr>
<tr class="separator:a5dae6a27fc7ccfc7043680a650e34c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10068762db2c75eae66343544042d050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a10068762db2c75eae66343544042d050">floydWarshell</a> (double **graph)</td></tr>
<tr class="separator:a10068762db2c75eae66343544042d050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce64a2d34a4329d5342e575e467b49f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#abce64a2d34a4329d5342e575e467b49f">coloring</a> ()</td></tr>
<tr class="separator:abce64a2d34a4329d5342e575e467b49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5a738fcda8957e55066fb1f5a6e59c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#afd5a738fcda8957e55066fb1f5a6e59c">draw</a> () const </td></tr>
<tr class="separator:afd5a738fcda8957e55066fb1f5a6e59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74beaae9726da79271fd26beef29ba49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a74beaae9726da79271fd26beef29ba49">print</a> (std::ostream &amp;) const </td></tr>
<tr class="separator:a74beaae9726da79271fd26beef29ba49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864bb472478c4ec26ed9641763a82cd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a864bb472478c4ec26ed9641763a82cd2">addNode</a> (std::string node)</td></tr>
<tr class="separator:a864bb472478c4ec26ed9641763a82cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7778be8b7825051f98f5c6c153ed5cdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a7778be8b7825051f98f5c6c153ed5cdd">removeNode</a> (std::string node)</td></tr>
<tr class="separator:a7778be8b7825051f98f5c6c153ed5cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa1c9cea0ead3b9fd86cd3412292b04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#aafa1c9cea0ead3b9fd86cd3412292b04">addEdge</a> (std::string fromNode, std::string toNode, double cost=1)</td></tr>
<tr class="separator:aafa1c9cea0ead3b9fd86cd3412292b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a547a81811de907718a19626676792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ad6a547a81811de907718a19626676792">removeEdge</a> (std::string from, std::string toNode)</td></tr>
<tr class="separator:ad6a547a81811de907718a19626676792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3df43d166c11ab232df2ffc2bce0061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ad3df43d166c11ab232df2ffc2bce0061">setWeight</a> (std::string fromNode, std::string toNode, double cost)</td></tr>
<tr class="separator:ad3df43d166c11ab232df2ffc2bce0061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4a29620eb446ca0e60570e6f51a74c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#afd4a29620eb446ca0e60570e6f51a74c">hasNegativeWeigth</a> () const </td></tr>
<tr class="separator:afd4a29620eb446ca0e60570e6f51a74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984015330b5d479b889c682f5e82eae6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a984015330b5d479b889c682f5e82eae6">isCyclic</a> () const </td></tr>
<tr class="separator:a984015330b5d479b889c682f5e82eae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ba611a8459d44582ac8fbc6ae5ead9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ae5ba611a8459d44582ac8fbc6ae5ead9">isConnected</a> () const </td></tr>
<tr class="separator:ae5ba611a8459d44582ac8fbc6ae5ead9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daacbca8eda74a7cfd52945f56aa9c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a9daacbca8eda74a7cfd52945f56aa9c1">isEulerian</a> () const </td></tr>
<tr class="separator:a9daacbca8eda74a7cfd52945f56aa9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73f6a24801008245e88052512a71f1f"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ab73f6a24801008245e88052512a71f1f">fromListADJToMatrixADJ</a> ()</td></tr>
<tr class="separator:ab73f6a24801008245e88052512a71f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16efcbd08d409f8811a6d066976db243"><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a16efcbd08d409f8811a6d066976db243">weightMatrix</a> ()</td></tr>
<tr class="separator:a16efcbd08d409f8811a6d066976db243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fe59e5f0093c54da5a3edd5a0325d2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a12fe59e5f0093c54da5a3edd5a0325d2">minRank</a> () const </td></tr>
<tr class="separator:a12fe59e5f0093c54da5a3edd5a0325d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f669ac551693108e3e2e7d4e6ce4ce8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a5f669ac551693108e3e2e7d4e6ce4ce8">maxRank</a> () const </td></tr>
<tr class="separator:a5f669ac551693108e3e2e7d4e6ce4ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239da990d0825846c3d35cb335e73f9b"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a239da990d0825846c3d35cb335e73f9b">adjacent</a> (std::string v) const </td></tr>
<tr class="separator:a239da990d0825846c3d35cb335e73f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a80e24fced1df4d16f6cc25011d305"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a26a80e24fced1df4d16f6cc25011d305">hasEdge</a> (std::string fromNode, std::string toNode) const </td></tr>
<tr class="separator:a26a80e24fced1df4d16f6cc25011d305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1e2caf0e7b2cea51e597e92c261d4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a8d1e2caf0e7b2cea51e597e92c261d4b">isOriented</a> () const </td></tr>
<tr class="separator:a8d1e2caf0e7b2cea51e597e92c261d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa363cde930f878c12f9d3b7988c36f4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#aa363cde930f878c12f9d3b7988c36f4a">isRegular</a> () const </td></tr>
<tr class="separator:aa363cde930f878c12f9d3b7988c36f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7b1c9c7e68d8c9521bf5c1ca27cb8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a6b7b1c9c7e68d8c9521bf5c1ca27cb8f">exist</a> (std::string) const </td></tr>
<tr class="separator:a6b7b1c9c7e68d8c9521bf5c1ca27cb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1efe623ea56a32bec0745f45128707"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a8f1efe623ea56a32bec0745f45128707">nodes</a> () const </td></tr>
<tr class="separator:a8f1efe623ea56a32bec0745f45128707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845a9101abc3efff7ed310cc2fa756e7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a845a9101abc3efff7ed310cc2fa756e7">edges</a> () const </td></tr>
<tr class="separator:a845a9101abc3efff7ed310cc2fa756e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa449a0e9c519f3e8add063e4c26c63f7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#aa449a0e9c519f3e8add063e4c26c63f7">rank</a> (std::string v) const </td></tr>
<tr class="separator:aa449a0e9c519f3e8add063e4c26c63f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4139dd37d2c30e975c506f1f57a3d6ff"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a4139dd37d2c30e975c506f1f57a3d6ff">weight</a> (std::string fromNode, std::string toNode) const </td></tr>
<tr class="separator:a4139dd37d2c30e975c506f1f57a3d6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a876329f980ce91482a94341160a5b4af"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGraphLib_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a876329f980ce91482a94341160a5b4af">generateRandomGraph</a> (int, bool graphType=<a class="el" href="classGraphLib_1_1Graph.html#a3111bb6cc59aedbc4290ed1b37668336">directed</a>)</td></tr>
<tr class="separator:a876329f980ce91482a94341160a5b4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2286bc629c2b3e39e49428a90a9ba89f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a2286bc629c2b3e39e49428a90a9ba89f">random</a> = 0</td></tr>
<tr class="separator:a2286bc629c2b3e39e49428a90a9ba89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60cf97b7bef2ca4d930b251581a3e7b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ae60cf97b7bef2ca4d930b251581a3e7b">circular</a> = 1</td></tr>
<tr class="separator:ae60cf97b7bef2ca4d930b251581a3e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3111bb6cc59aedbc4290ed1b37668336"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a3111bb6cc59aedbc4290ed1b37668336">directed</a> = true</td></tr>
<tr class="separator:a3111bb6cc59aedbc4290ed1b37668336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c94d852cc820c10aefd1ef0f587fb0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ac0c94d852cc820c10aefd1ef0f587fb0">undirected</a> = false</td></tr>
<tr class="separator:ac0c94d852cc820c10aefd1ef0f587fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aa27f00087e5578d92522f09a991dbad5"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; std::string, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">link</a></td></tr>
<tr class="separator:aa27f00087e5578d92522f09a991dbad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727ccf2fdc487a56e523a562f592b422"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <br class="typebreak"/>
bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">mapStringBool</a></td></tr>
<tr class="separator:a727ccf2fdc487a56e523a562f592b422"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a05961e5753c699ea21daeccbda11f734"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a05961e5753c699ea21daeccbda11f734">_Node</a> () const </td></tr>
<tr class="separator:a05961e5753c699ea21daeccbda11f734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0660792b0f9d2b8e7984f58f6608118e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a0660792b0f9d2b8e7984f58f6608118e">_Edge</a> () const </td></tr>
<tr class="separator:a0660792b0f9d2b8e7984f58f6608118e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11c2f08c36fe53a82bc50cc6551725f"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">link</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#af11c2f08c36fe53a82bc50cc6551725f">_EdgeWeight</a> () const </td></tr>
<tr class="separator:af11c2f08c36fe53a82bc50cc6551725f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac156a0e04a3e7cdff9015dd74f7c4f8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ac156a0e04a3e7cdff9015dd74f7c4f8e">_DFSUtil</a> (std::string v, <a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">mapStringBool</a> &amp;visited) const </td></tr>
<tr class="separator:ac156a0e04a3e7cdff9015dd74f7c4f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c906b8d9608a91a8d6b5bbf1e18eb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ad8c906b8d9608a91a8d6b5bbf1e18eb8">_DFSUtil2</a> (std::string v, <a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">mapStringBool</a> &amp;visited) const </td></tr>
<tr class="separator:ad8c906b8d9608a91a8d6b5bbf1e18eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5778bc515e6757169f1017dd69ed81a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a5778bc515e6757169f1017dd69ed81a8">_generateHtmlPage</a> () const </td></tr>
<tr class="separator:a5778bc515e6757169f1017dd69ed81a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34e0d3e0b3b7ab05ea412e2332bcda2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#ae34e0d3e0b3b7ab05ea412e2332bcda2">_generateJavascriptPage</a> () const </td></tr>
<tr class="separator:ae34e0d3e0b3b7ab05ea412e2332bcda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0aa9e4c26612953a27914ca9dd94e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a7c0aa9e4c26612953a27914ca9dd94e4">_generateEdge</a> (int)</td></tr>
<tr class="separator:a7c0aa9e4c26612953a27914ca9dd94e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110dbdff7dca94a4080c8e41dc33ca80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a110dbdff7dca94a4080c8e41dc33ca80">_isCyclicUtil</a> (std::string v, <a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">mapStringBool</a> visited, <a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">mapStringBool</a> recStack) const </td></tr>
<tr class="separator:a110dbdff7dca94a4080c8e41dc33ca80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c629f5ac9e6e3f5bfb5eae4853d0c4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a9c629f5ac9e6e3f5bfb5eae4853d0c4f">_printSolutionFloydWarshell</a> (int **dist)</td></tr>
<tr class="separator:a9c629f5ac9e6e3f5bfb5eae4853d0c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9425d5b9f754f74abd6030e2ece5d09d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a9425d5b9f754f74abd6030e2ece5d09d">direct</a></td></tr>
<tr class="separator:a9425d5b9f754f74abd6030e2ece5d09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d57aa86954b2fc260c8699dd9fdcd66"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a2d57aa86954b2fc260c8699dd9fdcd66">_node</a></td></tr>
<tr class="separator:a2d57aa86954b2fc260c8699dd9fdcd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784b9952b6bd927abf0068c10b21fb4f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">link</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a784b9952b6bd927abf0068c10b21fb4f">_edge</a></td></tr>
<tr class="separator:a784b9952b6bd927abf0068c10b21fb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fafe6bfd34afe63874f942408a5b858"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">link</a>, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraphLib_1_1Graph.html#a1fafe6bfd34afe63874f942408a5b858">_edgeWeight</a></td></tr>
<tr class="separator:a1fafe6bfd34afe63874f942408a5b858"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C++ implementation of a directed/undirected graph using the STL and the dracula javasript library to draw the graph </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aa27f00087e5578d92522f09a991dbad5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;std::string, std::string&gt; <a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">GraphLib::Graph::link</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>eg. &lt;v. u&gt; </p>

</div>
</div>
<a class="anchor" id="a727ccf2fdc487a56e523a562f592b422"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, bool&gt; <a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">GraphLib::Graph::mapStringBool</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab8f9277bc44213e8ec100eccfdc4a33e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>graphType</em> = <code><a class="el" href="classGraphLib_1_1Graph.html#a3111bb6cc59aedbc4290ed1b37668336">directed</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graphType</td><td>directed/undirect graph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e3fbf053855797d1da4df1421ee216f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>graphType</em> = <code><a class="el" href="classGraphLib_1_1Graph.html#a3111bb6cc59aedbc4290ed1b37668336">directed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add Node using regex eg. G("A-Z"), G(1-5), G(12-82)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>regex eg. A-Z, 1-6 </td></tr>
    <tr><td class="paramname">edgeType</td><td>random/circular edges generation </td></tr>
    <tr><td class="paramname">graphType</td><td>directed/undirect graph </td></tr>
  </table>
  </dd>
</dl>
<p>1-9, a-z, A-Z ...</p>
<p>10-17, 12-102 ... </p>

</div>
</div>
<a class="anchor" id="a3fb8d04de0175ec4005ee57564a8802c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraphLib_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy contructor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classGraphLib_1_1Graph.html">Graph</a></td><td>graph to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40bde368ad387204b3e1407fe6c93f51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GraphLib::Graph::~Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>default Distructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac156a0e04a3e7cdff9015dd74f7c4f8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::_DFSUtil </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">mapStringBool</a> &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>source node </td></tr>
    <tr><td class="paramname">visited</td><td>vector of boolean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>Mark the current node as visited and print it</p>
<p>Recur for all the vertices adjacent to this vertex </p>

</div>
</div>
<a class="anchor" id="ad8c906b8d9608a91a8d6b5bbf1e18eb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::_DFSUtil2 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">mapStringBool</a> &amp;&#160;</td>
          <td class="paramname"><em>visited</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mark the current node as visited and print it</p>
<p>Recur for all the vertices adjacent to this vertex </p>

</div>
</div>
<a class="anchor" id="a0660792b0f9d2b8e7984f58f6608118e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">link</a> &gt; Graph::_Edge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>vector of edge </dd></dl>

</div>
</div>
<a class="anchor" id="af11c2f08c36fe53a82bc50cc6551725f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; <a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">link</a>, double &gt; Graph::_EdgeWeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>weight of edges </dd></dl>

</div>
</div>
<a class="anchor" id="a7c0aa9e4c26612953a27914ca9dd94e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::_generateEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>random</p>
<p>circular </p>

</div>
</div>
<a class="anchor" id="a5778bc515e6757169f1017dd69ed81a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::_generateHtmlPage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate html page to draw the graph</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ae34e0d3e0b3b7ab05ea412e2332bcda2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::_generateJavascriptPage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate javascript page to draw the graph</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>dimension of the div</p>
<p>dimension of the div</p>
<p>customize the nodes</p>
<p>generate the nodes</p>
<p>generate the edges</p>
<p>insert the weight into the javascript code</p>
<p>draw using the dracula library </p>

</div>
</div>
<a class="anchor" id="a110dbdff7dca94a4080c8e41dc33ca80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::_isCyclicUtil </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">mapStringBool</a>&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphLib_1_1Graph.html#a727ccf2fdc487a56e523a562f592b422">mapStringBool</a>&#160;</td>
          <td class="paramname"><em>recStack</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to detect cycle in different DFS trees</p>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>
<p>Mark the current node as visited and part of recursion stack</p>
<p>Recur for all the vertices adjacent to this vertex</p>
<p>remove the vertex from recursion stack </p>

</div>
</div>
<a class="anchor" id="a05961e5753c699ea21daeccbda11f734"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Graph::_Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>vector of nodes </dd></dl>

</div>
</div>
<a class="anchor" id="a9c629f5ac9e6e3f5bfb5eae4853d0c4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::_printSolutionFloydWarshell </td>
          <td>(</td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aafa1c9cea0ead3b9fd86cd3412292b04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add edge to the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromNode</td><td>edge from node </td></tr>
    <tr><td class="paramname">toNode</td><td>edge to node </td></tr>
    <tr><td class="paramname">cost</td><td>weight of the edge, default is 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>if the nodes do not exist, create them</p>
<p>undirected graph </p>

</div>
</div>
<a class="anchor" id="a864bb472478c4ec26ed9641763a82cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add node to the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a239da990d0825846c3d35cb335e73f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; std::string &gt; Graph::adjacent </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>adjacent list </p>

</div>
</div>
<a class="anchor" id="a5dae6a27fc7ccfc7043680a650e34c06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::BFS </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sourceNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Breadth First Traversal for a <a class="el" href="classGraphLib_1_1Graph.html">Graph</a> </p>
<p>Mark all the vertices as not visited</p>
<p>Create a queue for BFS</p>
<p>Mark the current node as visited and enqueue it</p>
<p>'i' will be used to get all adjacent vertices of a vertex</p>
<p>Dequeue a vertex from queue and print it</p>
<p>Get all adjacent vertices of the dequeued vertex s If a adjacent has not been visited, then mark it visited and enqueue it </p>

</div>
</div>
<a class="anchor" id="abce64a2d34a4329d5342e575e467b49f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::coloring </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classGraphLib_1_1Graph.html">Graph</a> Coloring (Greedy Algorithm) :- FIXED By Wyvilo Assigns colors (starting from 0) to all vertices and prints the assignment of colors</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>remove common edges</p>
<p>temporaly turn graph into undirected (if not)</p>
<p>Assign the first color to first vertex</p>
<p>Initialize remaining V-1 vertices as unassigned</p>
<p>Assign colors to remaining V-1 vertices</p>
<p>Process all adjacent vertices and flag their colors as unavailable</p>
<p>Assign the found color</p>
<p>print the result </p>

</div>
</div>
<a class="anchor" id="a60547325c70266ede08ed887ff60ea19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::DFS </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sourceNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DFS traversal of the vertices reachable from v. It uses recursive <a class="el" href="classGraphLib_1_1Graph.html#ac156a0e04a3e7cdff9015dd74f7c4f8e">_DFSUtil()</a> </p>
<p>Mark all the vertices as not visited </p>

</div>
</div>
<a class="anchor" id="afd5a738fcda8957e55066fb1f5a6e59c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::draw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>draw the graph using html/javascript</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>execute default browser </p>

</div>
</div>
<a class="anchor" id="a845a9101abc3efff7ed310cc2fa756e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Graph::edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of edges </dd></dl>

</div>
</div>
<a class="anchor" id="a6b7b1c9c7e68d8c9521bf5c1ca27cb8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::exist </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>to control </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exist node? </dd></dl>

</div>
</div>
<a class="anchor" id="a10068762db2c75eae66343544042d050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::floydWarshell </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves the all-pairs shortest path problem using Floyd Warshall algorithm </p>
<p>dist[][] will be the output matrix that will finally have the shortest distances between every pair of vertices</p>
<p>Initialize the solution matrix same as input graph matrix. Or we can say the initial values of shortest distances are based on shortest paths considering no intermediate vertex.</p>
<p>Add all vertices one by one to the set of intermediate vertices. &mdash;&gt; Before start of a iteration, we have shortest distances between all pairs of vertices such that the shortest distances consider only the vertices in set {0, 1, 2, .. k-1} as intermediate vertices. -&mdash;&gt; After the end of a iteration, vertex no. k is added to the set of intermediate vertices and the set becomes {0, 1, 2, .. k}</p>
<p>Pick all vertices as source one by one</p>
<p>Pick all vertices as destination for the above picked source</p>
<p>If vertex k is on the shortest path from i to j, then update the value of dist[i][j] </p>

</div>
</div>
<a class="anchor" id="ab73f6a24801008245e88052512a71f1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ** Graph::fromListADJToMatrixADJ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert adjacent list into a matrix </p>
<p>matrix allocation</p>
<p>initialize matrix </p>

</div>
</div>
<a class="anchor" id="a876329f980ce91482a94341160a5b4af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraphLib_1_1Graph.html">Graph</a> Graph::generateRandomGraph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>graphType</em> = <code><a class="el" href="classGraphLib_1_1Graph.html#a3111bb6cc59aedbc4290ed1b37668336">directed</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>generate random <a class="el" href="classGraphLib_1_1Graph.html">Graph</a> with (max) n Node</p>
<p>Generate random graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxNode</td><td>max node of the generated graph </td></tr>
    <tr><td class="paramname">graphType</td><td>directed/undirect graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGraphLib_1_1Graph.html">Graph</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a26a80e24fced1df4d16f6cc25011d305"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::hasEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromNode</td><td>first node of edge </td></tr>
    <tr><td class="paramname">toNode</td><td>second node of edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>exist edge: (fromNode, toNode)? </dd></dl>

</div>
</div>
<a class="anchor" id="afd4a29620eb446ca0e60570e6f51a74c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::hasNegativeWeigth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Control if graph has negative weight</p>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="ae5ba611a8459d44582ac8fbc6ae5ead9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to check if all non-zero degree vertices are connected. It mainly does DFS traversal starting from</p>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>
<p>Mark all the vertices as not visited</p>
<p>Find a vertex with non-zero degree</p>
<p>If there are no edges in the graph, return true</p>
<p>Start DFS traversal from a vertex with non-zero degree</p>
<p>Check if all non-zero degree vertices are visited </p>

</div>
</div>
<a class="anchor" id="a984015330b5d479b889c682f5e82eae6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isCyclic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Time Complexity of this method is same as time complexity of DFS traversal which is O(V+E)</p>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>
<p>Mark all the vertices as not visited and not part of recursion stack</p>
<p>Call the recursive helper function to detect cycle in different DFS trees </p>

</div>
</div>
<a class="anchor" id="a9daacbca8eda74a7cfd52945f56aa9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::isEulerian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function returns one of the following values 0 &ndash;&gt; If grpah is not Eulerian 1 &ndash;&gt; If graph has an Euler path (Semi-Eulerian) 2 &ndash;&gt; If graph has an Euler Circuit (Eulerian)</p>
<dl class="section return"><dt>Returns</dt><dd>integer </dd></dl>
<p>Check if all non-zero degree vertices are connected</p>
<p>Count vertices with odd degree</p>
<p>If count is more than 2, then graph is not Eulerian</p>
<p>If odd count is 2, then semi-eulerian. If odd count is 0, then eulerian Note that odd count can never be 1 for undirected graph </p>

</div>
</div>
<a class="anchor" id="a8d1e2caf0e7b2cea51e597e92c261d4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>graph oriented or not? </dd></dl>

</div>
</div>
<a class="anchor" id="aa363cde930f878c12f9d3b7988c36f4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::isRegular </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>minRank = maxRank? </dd></dl>

</div>
</div>
<a class="anchor" id="a5f669ac551693108e3e2e7d4e6ce4ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Graph::maxRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max rank of a graph</p>
<dl class="section return"><dt>Returns</dt><dd>unsigned </dd></dl>

</div>
</div>
<a class="anchor" id="a12fe59e5f0093c54da5a3edd5a0325d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Graph::minRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Min rank of a graph</p>
<dl class="section return"><dt>Returns</dt><dd>unsigned </dd></dl>

</div>
</div>
<a class="anchor" id="a8f1efe623ea56a32bec0745f45128707"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Graph::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>number of nodes </dd></dl>

</div>
</div>
<a class="anchor" id="acf3c67e9e04fd94b80556ccbfa492a2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraphLib_1_1Graph.html">Graph</a>&amp; GraphLib::Graph::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGraphLib_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>operator= is not implemented </p>

</div>
</div>
<a class="anchor" id="a74beaae9726da79271fd26beef29ba49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the graph on the standard output</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aa449a0e9c519f3e8add063e4c26c63f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Graph::rank </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of nodes adjacent to v </dd></dl>

</div>
</div>
<a class="anchor" id="ad6a547a81811de907718a19626676792"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::removeEdge </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove edge from the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromNode</td><td>edge from node </td></tr>
    <tr><td class="paramname">toNode</td><td>edge to node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>undirected graph </p>

</div>
</div>
<a class="anchor" id="a7778be8b7825051f98f5c6c153ed5cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::removeNode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove node from the graph</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>remove the edge connected to the node</p>
<p>removing edges </p>

</div>
</div>
<a class="anchor" id="ad3df43d166c11ab232df2ffc2bce0061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::setWeight </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set weight to edge(fromNode, toNode)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toNode</td><td>edge to node </td></tr>
    <tr><td class="paramname">fromNode</td><td>edge from node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<p>undirected <a class="el" href="classGraphLib_1_1Graph.html">Graph</a> </p>

</div>
</div>
<a class="anchor" id="a13f6b627345753c59f03600b2dbc8113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraphLib_1_1Graph.html">Graph</a> Graph::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transpose of this graph</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGraphLib_1_1Graph.html">Graph</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4139dd37d2c30e975c506f1f57a3d6ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::weight </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fromNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>toNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromNode</td><td>first node of edge </td></tr>
    <tr><td class="paramname">toNode</td><td>second node of edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>weight of edge: (fromNode, toNode) </dd></dl>

</div>
</div>
<a class="anchor" id="a16efcbd08d409f8811a6d066976db243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** Graph::weightMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>matrix of edge's weight </dd></dl>
<p>matrix allocation</p>
<p>initialize matrix </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a784b9952b6bd927abf0068c10b21fb4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">link</a>&gt; GraphLib::Graph::_edge</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>eg. {&lt;v1, u1&gt;, &lt;v2, u2&gt;, ...} </p>

</div>
</div>
<a class="anchor" id="a1fafe6bfd34afe63874f942408a5b858"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="classGraphLib_1_1Graph.html#aa27f00087e5578d92522f09a991dbad5">link</a>, double&gt; GraphLib::Graph::_edgeWeight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>eg. {&lt;v1,u1&gt; = 1, &lt;v2,u2&gt; = 1 ,...} </p>

</div>
</div>
<a class="anchor" id="a2d57aa86954b2fc260c8699dd9fdcd66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; GraphLib::Graph::_node</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>eg. {v1, v2, v3, ...} </p>

</div>
</div>
<a class="anchor" id="ae60cf97b7bef2ca4d930b251581a3e7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::circular = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>generate a edge that forms a circular graph </p>

</div>
</div>
<a class="anchor" id="a9425d5b9f754f74abd6030e2ece5d09d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GraphLib::Graph::direct</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>direct graph or undirect </p>

</div>
</div>
<a class="anchor" id="a3111bb6cc59aedbc4290ed1b37668336"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::directed = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>generate directed <a class="el" href="classGraphLib_1_1Graph.html">Graph</a> </p>

</div>
</div>
<a class="anchor" id="a2286bc629c2b3e39e49428a90a9ba89f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::random = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>generate a random edge to connect the Node </p>

</div>
</div>
<a class="anchor" id="ac0c94d852cc820c10aefd1ef0f587fb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Graph::undirected = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>generate undirected <a class="el" href="classGraphLib_1_1Graph.html">Graph</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Graph_8hh_source.html">Graph.hh</a></li>
<li><a class="el" href="Graph_8cpp.html">Graph.cpp</a></li>
<li><a class="el" href="Graph__Inlines_8hh_source.html">Graph_Inlines.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 7 2014 12:28:46 for GraphLib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
